#!/usr/bin/env python3
"""
Visualize the sampling pattern generated by `next_location_on_sphere`.

Usage:
    python uniform_hemisphere_points.py <slices> <N>

Example:
    python uniform_hemisphere_points.py 2 8
"""

import argparse
import math
import numpy as np
import matplotlib.pyplot as plt


def spherical_to_cartesian(radius, inc, azi):
    """Convert spherical coords to Cartesian (x,y,z)."""
    x = radius * np.sin(inc) * np.cos(azi)
    y = radius * np.sin(inc) * np.sin(azi)
    z = radius * np.cos(inc)
    return x, y, z


def plot_positive_hemisphere(ax, radius):
    theta = np.linspace(0, math.pi / 2, 40)
    phi   = np.linspace(0, 2 * math.pi, 80)
    TH, PH = np.meshgrid(theta, phi)
    X, Y, Z = spherical_to_cartesian(radius, TH, PH)

    ax.plot_surface(X, Y, Z, alpha=0.2, color="lightgrey", linewidth=0)


def plot_slices(ax, radius, slices):
    def plot_slice(ax, radius, inc):
      phi   = np.linspace(0, 2 * math.pi, 80)
      TH, PH = np.meshgrid(inc, phi)
      X, Y, Z = spherical_to_cartesian(radius, TH, PH)
      ax.plot(X, Y, Z, color="blue")

    angle = math.pi / 2 / (slices + 1)
    for i in range(slices):
        plot_slice(ax, radius, angle * (i + 1))


def next_location_on_sphere(slices: int, i: int, N: int):
    if not (0 <= i < N) or not (1 <= slices <= N):
        raise ValueError("0 ≤ i < N and 1 ≤ slices ≤ N must hold")

    slice_angle = math.pi / 2 / (slices + 1)
    per_slice = (N + slices - 1) // slices
    current_slice = i // per_slice
    inc = slice_angle * (current_slice + 1)
    azi = (2 * math.pi * (i + 1)) / per_slice
    return inc, azi


def main():
    parser = argparse.ArgumentParser(
        description="Plot points produced by next_location_on_sphere on the "
                    "positive hemisphere (radius = 1).")
    parser.add_argument("slices", type=int, help="number of latitude bands")
    parser.add_argument("N", type=int, help="total number of points")
    args = parser.parse_args()

    slices, N = args.slices, args.N

    fig = plt.figure(figsize=(7, 7))
    ax = fig.add_subplot(projection="3d")

    radius = 1
    plot_positive_hemisphere(ax, radius)
    plot_slices(ax, radius, slices)

    for idx in range(N):
        th, ph = next_location_on_sphere(slices, idx, N)
        x, y, z = spherical_to_cartesian(radius, th, ph)

        ax.scatter(x, y, z, s=40, color="red")
        ax.text(x, y, z, f"{idx}", fontsize=8, color="blue")

    ax.set_xlim(-1, 1); ax.set_ylim(-1, 1); ax.set_zlim(0, 1)
    ax.set_xlabel("x");  ax.set_ylabel("y");  ax.set_zlabel("z")
    ax.set_title(f"Hemisphere sampling (slices={slices}, N={N})")
    plt.tight_layout()
    plt.show()


if __name__ == "__main__":
    main()
